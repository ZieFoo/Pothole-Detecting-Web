<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pothole Detection</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <style>
        body{
            background: #111;
            color: #fff;
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 16px;
        }
        h1{
            margin-bottom: 18px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        .media-row {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .media {
            width: 90%;
            max-width: 360px;
            border: 3px solid #00ff88;
            border-radius: 12px;
            box-shadow: 0 0 15px #00ff88;
            overflow: hidden;
            background: #000;
            position: relative;
        }
        video, img {
            width: 100%;
            height: auto;
            display: block;
        }
        #controls { 
            margin-top: 12px;
        }
        button{
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            background: #00ff88;
            color: #111;
            font-weight: bold;
            transition: 0.15s ease;
            margin: 6px;
        }
        button:active { transform: scale(0.98); }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        small { display:block; margin-top:8px; color:#9f9; }
        #screenshotCanvas { display: none; }
        .debug-panel {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            border: 2px solid #00ff88;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            text-align: left;
            font-family: monospace;
            font-size: 11px;
            max-height: 400px;
            overflow-y: auto;
        }
        .debug-panel h3 {
            color: #00ff88;
            margin-top: 0;
            text-align: center;
        }
        .log-entry {
            padding: 4px 8px;
            margin: 2px 0;
            border-left: 3px solid #666;
            background: #222;
        }
        .log-ok { border-color: #00ff00; color: #00ff00; }
        .log-warn { border-color: #ffaa00; color: #ffaa00; }
        .log-error { border-color: #ff0000; color: #ff0000; }
        .log-info { border-color: #00aaff; color: #00aaff; }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 10px 0;
        }
        .stat-item {
            background: #222;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
        }
        .stat-label {
            color: #888;
            font-size: 10px;
        }
        .stat-value {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
        }
        .video-status {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 3px 8px;
            background: rgba(0,0,0,0.8);
            border-radius: 3px;
            font-size: 10px;
            color: #00ff88;
        }
    </style>
</head>
<body>
    <h1>Pothole Detection - Live</h1>
    
    <div id="controls">
        <div style="margin-bottom: 10px;">
            <button id="start-btn">Start Live Detection</button>
            <button id="stop-btn" style="display:none;">Stop</button>
        </div>
        <div style="margin-bottom: 10px;">
            <button id="viewer-btn" onclick="window.open('/viewer', '_blank')">Open Viewer Page</button>
            <button onclick="window.open('/map', '_blank')" style="background: #ff8800;">View Pothole Map</button>
        </div>
        <div style="margin-bottom: 10px;">
            <button id="toggle-debug" onclick="toggleDebug()" style="background: #8800ff; font-size: 18px; padding: 12px 24px;">SHOW DEBUG</button>
        </div>
        <small>Left: Raw camera preview (Live) â€” Right: Annotated (Server detection via WebRTC)</small>
    </div>

    <div class="media-row">
        <div class="media">
            <video id="localVideo" autoplay playsinline muted></video>
            <div class="video-status" id="localStatus">OFF</div>
        </div>

        <div class="media">
            <video id="remoteVideo" autoplay playsinline></video>
            <div class="video-status" id="remoteStatus">OFF</div>
        </div>
    </div>
    
    <canvas id="screenshotCanvas"></canvas>

    <div id="debugPanel" class="debug-panel" style="display:none;">
        <h3>Debug Console</h3>
        <button onclick="clearDebugLog()" style="margin-bottom: 10px; padding: 5px 10px; font-size: 11px;">Clear Log</button>

        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-label">Connection State</div>
                <div class="stat-value" id="statConnection"></div>
            </div>
            <div class="stat-item">
                <div class="stat-label">ICE State</div>
                <div class="stat-value" id="statIce">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Local Video</div>
                <div class="stat-value" id="statLocal">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Remote Video</div>
                <div class="stat-value" id="statRemote">-</div>
            </div>
        </div>

        <div id="logContainer"></div>
    </div>

    <script>
    const startBtn = document.getElementById("start-btn");
    const stopBtn = document.getElementById("stop-btn");
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const screenshotCanvas = document.getElementById("screenshotCanvas");
    const screenshotCtx = screenshotCanvas.getContext('2d');
    const localStatus = document.getElementById("localStatus");
    const remoteStatus = document.getElementById("remoteStatus");
    const logContainer = document.getElementById("logContainer");

    let pc = null;
    let localStream = null;
    let gpsWatchId = null;
    let currentLocation = null;
    let lastLoggedTime = 0;
    let detectionPollInterval = null;
    let statsInterval = null;
    let remoteTrackReceived = false;
    let remoteVideoPlaying = false;
    const LOG_INTERVAL = 5000;
    const DETECTION_POLL_INTERVAL = 2000;

    function debugLog(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${timestamp}] ${message}`;
        logContainer.insertBefore(entry, logContainer.firstChild);

        while (logContainer.children.length > 100) {
            logContainer.removeChild(logContainer.lastChild);
        }

        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    function toggleDebug() {
        const panel = document.getElementById('debugPanel');
        const btn = document.getElementById('toggle-debug');
        if (panel.style.display === 'none') {
            panel.style.display = 'block';
            btn.textContent = 'HIDE DEBUG';
        } else {
            panel.style.display = 'none';
            btn.textContent = 'SHOW DEBUG';
        }
    }

    function clearDebugLog() {
        logContainer.innerHTML = '';
        debugLog('Log cleared', 'info');
    }

    function updateStats() {
        if (!pc) return;
        
        document.getElementById('statConnection').textContent = pc.connectionState || '-';
        document.getElementById('statIce').textContent = pc.iceConnectionState || '-';
        document.getElementById('statLocal').textContent =
            localVideo.videoWidth ? `${localVideo.videoWidth}x${localVideo.videoHeight}` : 'No video';
        document.getElementById('statRemote').textContent =
            remoteVideo.videoWidth ? `${remoteVideo.videoWidth}x${remoteVideo.videoHeight}` : 'No video';           
    }

    function captureScreenshotFromVideo(video, label) {
        if (!video.videoWidth || !video.videoHeight || video.readyState <2) {
            debugLog(`${label} video not ready for screenshot`, 'warn');
            return null;
        }

        screenshotCanvas.width = video.videoWidth;
        screenshotCanvas.height = video.videoHeight;
        screenshotCtx.drawImage(video, 0, 0);

        debugLog(`Screenshot captured from ${label}: ${video.videoWidth}x${video.videoHeight}`, 'ok');

        return screenshotCanvas.toDataURL('image/jpeg', 0.8);
    }

    async function getBackCameraStream() {
        debugLog('Requesting camera access...', 'info');
        try {
            const s = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: { exact: "environment" },
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            debugLog('Got back camera (environment mode)', 'ok');
            return s;
        } catch(err) {
            debugLog('Back camera not available, trying fallback...', 'warn');
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoInputs= devices.filter(d => d.kind === 'videoinput');
                debugLog(`Found ${videoInputs.length} video input(s)`, 'info');

                let chosen = videoInputs.find(d => /back|rear|environment|wide/i.test(d.label));
                if (!chosen && videoInputs.length) chosen = videoInputs[videoInputs.length - 1];

                if (chosen){
                    debugLog(`Using camera: ${chosen.label}`, 'info');
                    const s = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: chosen.deviceId },
                            width: { ideal: 1280},
                            height: { ideal: 720 }
                        },
                        audio: false
                    });
                    debugLog('Got camera via device ID', 'ok');
                    return s;
                }
            } catch (e) {
                debugLog(`Fallback camera error: ${e.message}`, 'error');
            }
            debugLog('Using any available camera', 'warn');
            return await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720}
                },
                audio: false
            });
        }
    }

    function startGPSTracking() {
        if (!navigator.geolocation) {
            debugLog('Geolocation not supported', 'warn');
            return;
        }

        gpsWatchId = navigator.geolocation.watchPosition(
            (position) => {
                currentLocation = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy
                };
                debugLog(`GPS: ${currentLocation.latitude.toFixed(6)}, ${currentLocation.longitude.toFixed(6)}`, 'info');
            },
            (error) => {
                debugLog(`GPS error: ${error.message}`, 'error');
            },
            {
                enableHighAccuracy: true,
                maximumAge: 1000,
                timeout: 5000
            }
        );
    }

    function stopGPSTracking() {
        if (gpsWatchId !== null) {
            navigator.geolocation.clearWatch(gpsWatchId);
            gpsWatchId = null;
            currentLocation = null;
            debugLog('GPS tracking stopped', 'info');
        }
    }

    async function logPotholeDetection(detectionCount, confidence, boundingBoxes) {
        if (!currentLocation) {
            return;
        }

        if (detectionCount === 0) {
            return;
        }

        const now = Date.now();
        if (now - lastLoggedTime <  LOG_INTERVAL) {
            return;
        }
        lastLoggedTime = now;

        const screenshotAnnotated = captureScreenshotFromVideo(remoteVideo, 'annotated (remote)');
        const screenshotLive = captureScreenshotFromVideo(localVideo, 'live (local)');

        if(!screenshotAnnotated && !screenshotLive) {
            debugLog('Failed to capture any screenshots', 'error');
            return;
        }

        try {
            const response = await fetch('/log_pothole', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    latitude: currentLocation.latitude,
                    longitude: currentLocation.longitude,
                    accuracy: currentLocation.accuracy,
                    confidence: confidence,
                    detection_count: detectionCount,
                    bounding_boxes: boundingBoxes,
                    screenshot_annotated: screenshotAnnotated,
                    screenshot_live: screenshotLive
                })
            });

            const result = await response.json();
            if (result.status === 'logged') {
                debugLog(`Pothole logged: ${detectionCount} detection(s), confidence ${(confidence*100).toFixed(1)}%`, 'ok');
            }
        } catch (err) {
            debugLog(`Error logging pothole: ${err.message}`, 'error');
        }
    }

    async function pollDetections() {
        try {
            const response = await fetch('/get_detection_info');
            const data = await response.json();

            if (data.count > 0) {
                await logPotholeDetection(data.count, data.max_confidence, data.boxes);
            }
        } catch (err) {
            debugLog(`Error polling detections: ${err.message}`, 'error');
        }
    }

    function startDetectionPolling() {
        detectionPollInterval= setInterval(pollDetections, DETECTION_POLL_INTERVAL);
        debugLog('Detection polling started', 'ok');
    }

    function stopDetectionPolling() {
        if (detectionPollInterval) {
            clearInterval(detectionPollInterval);
            detectionPollInterval = null;
            debugLog('Detection polling stopped', 'info');
        }
    }

    async function negotiate() {
        try {
            debugLog('Creating WebRTC offer...', 'info');
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            debugLog('Local description set', 'ok');

            debugLog('Waiting for ICE gathering...', 'info');
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    debugLog('ICE gathering timeout (5s), proceeding anyway', 'warn');
                    resolve();
                }, 5000);

                if (pc.iceGatheringState === 'complete') {
                    clearTimeout(timeout);
                    resolve();
                } else {
                    const checkState = () => {
                        debugLog(`ICE gathering state: ${pc.iceGatheringState}`, 'info');
                        if (pc.iceGatheringState === 'complete') {
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            clearTimeout(timeout);
                            resolve();
                        }
                    };
                    pc.addEventListener('icegatheringstatechange', checkState);
                }
            });

            debugLog('Sending offer to server...', 'info');
            const response = await fetch('/offer', {
                body: JSON.stringify({
                    sdp: pc.localDescription.sdp,
                    type: pc.localDescription.type,
                }),
                headers: {
                    'Content-Type': 'application/json'
                },
                method: 'POST'
            });

            if (!response.ok) {
                throw new Error(`Server returned ${response.status}`);
            }

            const answer = await response.json();
            debugLog('Received answer from server', 'ok');

            await pc.setRemoteDescription(answer);
            debugLog('Remote description set successfully', 'ok');
        } catch (e) {
            debugLog(`Negotiation error: ${e.message}`, 'error');
            throw e;
        }
    }

    startBtn.onclick = async () => {
        startBtn.disabled = true;
        startBtn.innerText = "Starting...";
        debugLog('=== Starting Detection Session ===', 'info');

        try{
            localStream = await getBackCameraStream();
        } catch (err) {
            debugLog(`Camera access failed: ${err.message}`, 'error');
            alert("Unable to access camera: " + (err && err.message ? err.message : err));
            startBtn.disabled = false;
            startBtn.innerText = "Start Live Detection";
            return;
        }

        localVideo.srcObject = localStream;

        localVideo.onloadedmetadata = () => {
            debugLog(`Local video loaded: ${localVideo.videoWidth}x${localVideo.videoHeight}`, 'ok');
            localStatus.textContent = `${localVideo.videoWidth}x${localVideo.videoHeight}`;
        };

        localVideo.onplay = () => {
            debugLog('Local video playing', 'ok');
        };

        startGPSTracking();

        const config = {
            iceServers: [
                {urls: 'stun:stun.l.google.com:19302'},
                {urls: 'stun:stun1.l.google.com:19302'},
                {urls: 'stun:stun2.l.google.com:19302'}
            ],
            iceCandidatePoolSize: 10
        };
        pc = new RTCPeerConnection(config);
        debugLog('RTCPeerConnection created', 'ok');
        
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                debugLog(`ICE candidate: ${event.candidate.candidate.substring(0, 50)}...`, 'info');
            } else {
                debugLog('ICE candidate gathering complete', 'ok');
            }
        };

        localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
            debugLog(`Added local track: ${track.kind} (${track.label})`, 'ok');
        });

        pc.addEventListener('track', (evt) => {
            debugLog(`Remote track received: ${evt.track.kind}`, 'ok');
            remoteTrackReceived = true;

            if (evt.track.kind === 'video'){
                if (remoteVideo.srcObject !== evt.streams[0]) {
                    remoteVideo.srcObject = evt.streams[0];
                    debugLog('Remote video stream set', 'ok');

                    remoteVideo.play().catch(err => {
                        debugLog(`Initial play attempt failed (expected): ${err.message}`, 'warn');
                    });

                    remoteVideo.onloadedmetadata = () => {
                        debugLog(`Remote video metadata loaded: ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`, 'ok');
                        remoteStatus.textContent = `${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`;

                        remoteVideo.play().then(() => {
                            debugLog('Remote video play() called successfully', 'ok');
                        }).catch(err => {
                            debugLog(`Remote video play() failed: ${err.message}`, 'error');
                        });
                    };

                    remoteVideo.onplay = () => {
                        debugLog('Remote video started playing', 'ok');
                        remoteVideoPlaying = true;
                        remoteStatus.style.color = '#00ff00';
                    };
                    
                    remoteVideo.onerror = (e) => {
                        debugLog(`Remote video error: ${e}`, 'error');
                        remoteStatus.style.color = '#ff0000';
                    };

                    setTimeout(() => {
                        if (!remoteVideoPlaying) {
                            debugLog('WARNING: Remote video not playing after 2s', 'error');
                            debugLog(`Remote video state: readyState=${remoteVideo.readyState}, paused=${remoteVideo.paused}`, 'warn');

                            debugLog('Attempting to play video again...', 'warn');
                            remoteVideo.play().then(() => {
                                debugLog('Second play() attempt succeeded!', 'ok');
                            }).catch(err => {
                                debugLog(`Second play() attempt failed: ${err.message}`, 'error');
                            });
                        }
                    }, 2000);
                }
            }
        });

        pc.addEventListener('connectionstatechange', () => {
            debugLog(`Connection state: ${pc.connectionState}`, 'info');
            if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                debugLog('Connection failed/disconnected', 'error');
                stopBtn.click();
            } else if (pc.connectionState === 'connected') {
                debugLog('WebRTC connection established successfully', 'ok');
            }
        });

        pc.addEventListener('iceconnectionstatechange', () => {
            debugLog(`ICE connection state: ${pc.iceConnectionState}`, 'info');
        });

        pc.addEventListener('signalingstatechange', () => {
            debugLog(`Signaling state: ${pc.signalingState}`, 'info');
        });

        try {
            await negotiate();
            
            statsInterval = setInterval(updateStats, 1000);

            startDetectionPolling();

            startBtn.style.display = "none";
            stopBtn.style.display = "inline-block";
            startBtn.disabled = false;
            startBtn.innerText = "Start Live Detection";

            setTimeout(() => {
                if (!remoteTrackReceived) {
                    debugLog('WARNING: No remote track received after 5 seconds!', 'error');
                    debugLog('This indicates server-side issue with VideoTransformTrack', 'error');
                }
            }, 5000);

        } catch (e) {
            debugLog(`Failed to start: ${e.message}`, 'error');
            alert("Failed to start WebRTC: " + e.message);
            startBtn.disabled = false;
            startBtn.innerText ="Start Live Detection";
            stopGPSTracking();
        }
    };

    stopBtn.onclick = async () => {
        debugLog('=== Stopping Detection Session ===', 'info');

        if (statsInterval) {
            clearInterval(statsInterval);
            statsInterval = null;
        }

        if (pc) {
            pc.close();
            pc = null;
        }
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        stopGPSTracking();
        stopDetectionPolling();

        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        localStatus.textContent = 'OFF';
        remoteStatus.textContent = 'OFF';
        remoteStatus.style.color = '#00ff88';

        remoteTrackReceived = false;
        remoteVideoPlaying = false;

        try{ 
            await fetch('/close', { method: 'POST' });
        } catch (e) {
            debugLog(`Error closing connection: ${e.message}`, 'error');
        }

        startBtn.style.display = "inline-block";
        stopBtn.style.display = "none";

        debugLog('Detection stopped', 'ok');
    };

    window.addEventListener('load', () => {
        debugLog(`Browser: ${navigator.userAgent}`, 'info');
        debugLog(`Platform: ${navigator.platform}`, 'info');
        debugLog(`WebRTC supported: ${!!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)}`, 'info');
    });    
    </script>
</body>
</html>